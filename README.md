### 参考了[nushell](https://www.nushell.sh/),可视此为其拙劣简化版。

##  实验目的
探索、理解并掌握操作系统命令解释器的设计原理和实现机制，基于 Linux 内核进行相
应命令解释程序的设计和实现，并在 Linux 操作系统平台上加以测试验证。

## 实验内容
分析、设计与实现基于 Linux 内核的命令解释程序（Shell），主要包括系统环境变量的设
置和初始化、系统命令提示符显示、命令辨别解析（区分内部命令与外部命令及不同内部命
令）、典型内部命令（譬如显示指定目录下文件列表、显示文本文件内容、文件拷贝、文件删
除、空文件创建、日期设置/显示）处理等功能，并在 Linux 操作系统上测试验证。

## 实验要求

Linux 命令解释程序功能设计要求：
   1. 选取和设计实现一组内部命令（五条以上）；
   2. 外部命令执行采用直接调用 exec 系统调用的方式来实现；
   3. 至少一条内部命令采用直接调用相应系统调用的方式来实现；
   4. 系统环境变量（至少包括当前目录）支持；
   5. 在 Linux 操作系统上启用（或替换原命令解释程序 Shell）并测试验证。

实验报告撰写和提交要求：
   1. 实验报告内容，须涵盖开发环境、运行环境、测试环境、源程序文件及源码清单（包
   括 Makefile 文件，如果有的话）、实验步骤、技术难点及解决方案、关键数据结构和算法流程、
   编译运行测试过程及结果截图、疑难解惑及经验教训、结论与体会等；
   2. 在实验报告内容（如运行结果截图等适当位置）中应有机融入个人姓名、学号、计
   算机系统信息等凸显个人标记特征的信息；
   3. 实验报告文档提交格式可为 Word 文档、WPS 文档或 PDF 文档。

## 实现功能
### 命令
* ls
* cd
* mkdir
* pwd
* exit
* help
* count
### 流程
所有命令都实现了`Command` trait，并各有`Signature`结构体描述其名称参数用途等等（其中参数分为位置参数和flag参数，又各分为强制和可选，位置参数还可以是无限个元素），  
然后保存在`CommandRegistry`中，供以后使用。
程序运行之后，首先创建一个`Context`结构体，其中保存着之前的`CommandRegistry`等数据。然后经过一些其他初始化操作之后，进入循环。

使用[rustyline](https://docs.rs/rustyline/6.0.0/rustyline)读取一行，再使用[nom](https://docs.rs/nom/5.1.0/nom/)将
这行解析为用'|'隔开的`Pipeline`，这时候只是简单的tokenized，而且保存的只有各token的`Span`，并未真正复制解析原数据。

`classify_pipeline`：进一步解析`pipeline`中的每个元素。对于每个元素，先获取首个`token`，根据名字判断是内部命令还是外部命令。
如果是内部命令，将参数分为命名参数和位置参数。如果是外部命令，将各参数简单地复制为字符串。

`run_pipeline`：对于内部命令，第一步先`evaluate_args`将参数转换为实际值，某些有特定参数的命令，  
可以定义其特定参数的结构体，然后使用[serde](http://serde.rs/)自动实现`Deserialize`trait。根据参数结构体，
使用自定义的`ConfigDeserializer`将evaluated的参数进一步转换为特定类型的值。这样实际执行的时候，就可以使用转换好的自定义结构体，
而不是从参数中一个一个手动转换了。对于外部命令，使用标准库的`Command`执行命令。对于多个命令piped，可以将前一个命令的输出值
当成下一个命令的输入值来传递（除内部命令和外部命令外都使用StdIO实现）。


### 特性
* 跨平台
* pipeline：如`ls | count`，可以输出当前目录的所有文件和目录数量之和
* help：可以根据各命令的signature输出相应信息.
![](http://cdn.lsongzhi.cn/blog/20200213235455.png)
* 对于执行过程中的错误，获取然后输出。目前解析过程中特定token解析失败可以输出包含其位置的错误。
![](http://cdn.lsongzhi.cn/blog/20200213235823.png)
* 使用除字符串以外多种类型的值
